# Zookeeper服务注册与发现：

## 服务化背景

多数公司的软件开发都是从一个单一的系统开始，以最快的速度进行迭代开发，而随着公司业务的发展，在原有系统上的功能添加导致系统越来越庞大，其带来了几个问题：

1. 单一系统部署在单机上，随着访问量的提升，单机的性能受限，降低了服务的可用性。
2. 系统的维护复杂，启动速度非常缓慢，日志复杂等
3. 同时单一系统导致了一个复杂系统都必须由同一种语言进行开发

如何解决这些问题，业务服务化是个有效的手段来解决大规模系统的性能瓶颈和复杂性，通过拆分，可以将系统拆分成不通的子系统，其带来的好处是：
1. 系统压力得到分流，同时方面扩展，对压力较大的子系统进行相关扩展。
2. 各个业务模块的业务逻辑少，系统维护性提高

同时服务化也带来了一系列的问题：
1. 随着系统服务越来越多，如何管理这些服务？

1. 如何把请求发送到提供统一服务的不通主机上？
2. 如果提供服务的主机有上下线等，如何将这些信息提供给依赖方？

zookeeper是解决上述问题的一种方案，zookeeper官方描述，其能够：

1. 配置信息的存储中心服务器
2. 命名服务
3. 分布式的协调（锁）
4. Master选举

Zookeeper作为服务注册和发现的解决方案，其优点如下：
1. 简单api，
2. 多个公司选择，阿里（Dubbo）以及国外多个公司的选择
3. 支持多种语言客户端

![](/assets/wKioL1dF09nw54OhAAA-GqTDZPI375.jpg-s_3885195311.jpg)

## 服务提供者

服务提供者作为服务的提供方将自身的服务信息注册到Zk（注册中心），服务信息包括：

1. 隶属哪个系统
2. 服务的ip和端口
3. 服务请求的url
4. 服务的权重等

## 服务注册中心

服务注册中心主要提供所有的服务注册信息的中心存储，同时将服务注册信息的更新通知给服务消费者。

## 服务消费者

服务消费者主要职责：

1. 服务消费者启动时从服务注册中心获取需要的服务注册信息
2. 将服务注册信息缓存在本地
3. 监听服务注册信息的变更，如接手到服务注册中心的变更通知，更新本地缓存
4. 根据本地缓存中的服务注册信息构建服务请求调用列表，并根据负载均衡等策略进行请求分发
5. 对服务提供方的存活进行检测，如果出现不可用的服务提供方，将从本地缓存中剔除。

举例如下
![](/assets/zk.png)

在zk的根目录下形成了一颗树\/Company\/Services\/Porvider2\/service2\/producers\/URI,其中company只定为公司或者大部门，services表示这个是微服务属性，Provider表示服务提供方，一个服务提供方可能提供多个服务，service为服务的id，producers为服务的生产者，考虑到负载均衡，高可用等，一个生产者可能部署在多个节点上或者多个进程，提供多个URI进行访问。consumers表示一个服务被哪些消费者进行消费，对服务的管理起到重要作用。















