# Paxos

说起paxos，需要稍微提提二段提交。简单来说，二阶段提交就是1.一个节点询问其他节点，我是不是可以进行消息提交。2.如果收到所有人的同意，则告诉大家，开始提交吧。这个协议在实际中并不能很好的解决分布式中信息同步问题。例如只要有节点失效，就会发生得不到所有人同意的结果，在超时后，这一次提交失败，等一系列问题。但是paxos在对二段提交进行了优化后，得到了一个比较好的解决办法。 paxos协议引入了多数派，以及消息编号的概念。在1准备时，询问2\/n+1的参与者，要求他们保证不会接受小于编号n的提交。 2.如果得到了2\/n+1的回复，则可以开始告诉2\/n+1的参与者进行消息的提交。 可以明显的看出，这就是对二段提交的一个优化版。就是这么一个比较巧妙的思想，解决了一些二阶段提交带来的问题。

## **基本算法\(basic paxos\)**

**[算法](http://lib.csdn.net/base/datastructure "算法与数据结构知识库")**中的参与者主要分为三个角色，同时每个参与者又可兼领多个角色:

**proposer **提出提案，提案信息包括提案编号和提议的value;

**acceptor **收到提案后可以接受\(accept\)提案;

**learner **只能"学习"被批准的提案;

算法\(决议的提出与批准\)主要分为两个阶段:

1. prepare阶段：

  \(1\). 当Porposer希望提出方案V1，首先发出prepare请求至大多数Acceptor。Prepare请求内容为序列号&lt;SN1&gt;;

  \(2\). 当Acceptor接收到prepare请求&lt;SN1&gt;时，检查自身上次回复过的prepare请求&lt;SN2&gt;

  a\). 如果SN2&gt;SN1，则忽略此请求，直接结束本次批准过程;

  b\). 否则检查上次批准的accept请求&lt;SNx，Vx&gt;，并且回复&lt;SNx，Vx&gt;；如果之前没有进行过批准，则简单回复&lt;OK&gt;;

2. accept批准阶段：

  \(1a\). 经过一段时间，收到一些Acceptor回复，回复可分为以下几种:

  a\). 回复数量满足多数派，并且所有的回复都是&lt;OK&gt;，则Porposer发出accept请求，请求内容为议案&lt;SN1，V1&gt;;

  b\). 回复数量满足多数派，但有的回复为：&lt;SN2，V2&gt;，&lt;SN3，V3&gt;……则Porposer找到所有回复中超过半数的那个，假设为&lt;SNx，Vx&gt;，则发出accept请求，请求内容为议案&lt;SN1，Vx&gt;;

  c\). 回复数量不满足多数派，Proposer尝试增加序列号为SN1+，转1继续执行;

  \(1b\). 经过一段时间，收到一些Acceptor回复，回复可分为以下几种:

  a\). 回复数量满足多数派，则确认V1被接受;

  b\). 回复数量不满足多数派，V1未被接受，Proposer增加序列号为SN1+，转1继续执行;

  \(2\). 在不违背自己向其他proposer的承诺的前提下，acceptor收到accept 请求后即接受并回复这个请求。


** Paxos算法在出现竞争的情况下，其收敛速度很慢，甚至可能出现活锁的情况**，例如当有三个及三个以上的proposer在发送prepare请求后，很难有一个proposer收到半数以上的回复而不断地执行第一阶段的协议。因此，为了避免竞争，加快收敛的速度，在算法中引入了一个Leader这个角色，在正常情况下同时应该最多只能有一个参与者扮演Leader角色，而其它的参与者则扮演Acceptor的角色，同时所有的人又都扮演Learner的角色。

 在这种优化算法中，**只有Leader可以提出议案，从而避免了竞争使得算法能够快速地收敛而趋于一致**，此时的paxos算法在本质上就退变为两阶段提交协议。但在异常情况下，系统可能会出现多Leader的情况，但这并不会破坏算法对一致性的保证，此时多个Leader都可以提出自己的提案，优化的算法就退化成了原始的paxos算法。



# Gossip流言协议

gossip协议是一个神奇的协议。它常用于P2P的通信协议，这个协议就是模拟人类中传播谣言的行为而来。简单的描述下这个协议，首先要传播谣言就要有种子节点。种子节点每秒都会随机向其他节点发送自己所拥有的节点列表，以及需要传播的消息。任何新加入的节点，就在这种传播方式下很快地被全网所知道。这个协议的神奇就在于它从设计开始就没想到信息一定要传递给所有的节点，但是随着时间的增长，在最终的某一时刻，全网会得到相同的信息。当然这个时刻可能仅仅存在于理论，永远不可达。

redis cassandra等采用gossip协议，gossip带来的缺点是网络流量较大。

